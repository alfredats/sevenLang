#+TITLE: Prolog

Note: I am using the swi flavor of prolog. YMMV.

* Notes from each day:
** Day 1: An excellent driver
*** Notes
*Intro*
- Prolog is a rules-based language for expressing logic and asking questions
- Prolog expressions are made up of logical rules & relationships, and also queries
- Prolog is about describing the world through the logical rules & relationships, then presenting logical problems with queries that the computer can then try to solve.
- This means we don't actually have to write the logic!


*syntax*
- beginning a word with a lowercased char tells prolog that it is an atomic fact, or an atom for short 
- beginning a word with a uppercased char or underscore -> variable

- Here's an example of a prolog file  
 #+begin_src prolog :tangle friends.pl
   likes(wallace,cheese). % these are facts. This line particularly reads like "wallace likes cheese".
   likes(grommit,cheese).
   likes(wendolene,sheep).

   friend(X,Y) :- \+(X = Y),likes(X,Z),likes(Y,Z). % these are rules
   % specifically, this rule is known as friend/2 (the friend rule with 2 parameters)
   % it consists of 3 subgoals (X & Y cannot be the same, X must like Z, Y must like Z)
   % all three must be true for this rule to be true
#+end_src

- within rules, =:-= denotes a subgoal, =\+= does logical negation
- Within the prolog repl, =['friends'].= loads the above file. It returns =true.= when successful


*queries*
- consider the following knowledge base
  #+begin_src prolog :tangle food.pl
    food_type(velveeta, cheese). % "velveeta is a food_type of cheese"
    food_type(ritz, cracker).
    food_type(spam, meat).
    food_type(sausage, meat).
    food_type(jolt, soda).
    food_type(twinkle, dessert).

    flavor(sweet, dessert).
    flavor(savory, meat).
    flavor(savory, cheese).
    flavor(sweet, soda).

    food_flavor(X, Y) :- food_type(X,Z), flavor(Y,Z).

  #+end_src

- load the =food.pl= file and execute a query =food_type(What, meat).=, prolog returns a single answer.
- use =;= to ask prolog to find another.


*Binding & Unification*
- === is not variable assignment, but is a unification operation (think of it like how C handles variable references)
- unification operator === is infix, and tries to make the structures involved identical

  #+begin_src prolog :tangle ohmy.pl
    cat(lion).
    cat(tiger).

    dorothy(X,Y,Z) :- X=lion, Y=tiger, Z=bear.
    twin_cats(X,Y) :- cat(X), cat(Y).

  #+end_src

- loading the database and running the query =dorothy(One,Two,Three).= returns
  #+begin_src prolog
    ?- dorothy(One,Two,Three).
    One = lion,
    Two = tiger,
    Three = bear.

  #+end_src

  In this case, prolog unifies =X,Y,Z= to =lion, tiger, bear= within the goals of =dorothy=. Afterwhich, it unifies =X,Y,Z= to =One, Two, Three=.

  - if we ran =twin_cats(One,Two).= instead, we get
    #+begin_src prolog
      ?- twin_cats(One,Two).
      One = Two, Two = lion ;
      One = lion,
      Two = tiger ;
      One = tiger,
      Two = lion ;
      One = Two, Two = tiger.
    #+end_src

    Prolog works through all possible combinations of X & Y based on the facts and information available within the goals.

*** Self-Study
*Find*
1) https://www.cpp.edu/~jrfisher/www/prolog_tutorial/contents.html
   http://www.lix.polytechnique.fr/~liberti/public/computing/prog/prolog/prolog-tutorial.html
2) https://swi-prolog.discourse.group/
3) SWI Prolog: https://www.swi-prolog.org/pldoc/man?section=quickstart

*Do*
1)
     #+begin_src prolog :tangle books.pl
       author(norwegianWood,murakami).
       author(oneQ84, murakami).
       author(colorlessTsukuru, murakami).
       author(neverLetMeGo, ishiguro).
       author(devotionOfSuspectX, higashino).
       author(doAndroidsDreamOfElectricSheep, philipKdick).

       books(Y,L) :- findall(X, author(X,Y), L).
     #+end_src

2) running =books(murakami, L)= yields =L = [norwegianWood, oneQ84, colorlessTsukuru].=

3)
   #+begin_src prolog :tangle music.pl
     instrument(hendrix, guitar).
     instrument(eddieVanHalen, guitar).
     instrument(axelRose, guitar).
     instrument(dukeEllington, piano).
     instrument(theloniousMonk, piano).
     instrument(louisArmstrong, trumpet).

     genre(hendrix,rock).
     genre(eddieVanHalen, rock).
     genre(axelRose, rock).
     genre(dukeEllington, jazz).
     genre(theloniousMonk, jazz).
     genre(louisArmstrong, jazz).


     instrumentalists(Y,L) :- findall(X, instrument(X,Y), L).
   #+end_src

** Day 2: Fifteen Minutes to Wapner
*** Notes
- A rule can have multiple clauses; only one of them needs to be true for the rule to be true
- Take the following:
  #+begin_src prolog :tangle family.pl
    father(david, job).
    father(job, michael).

    % a rule can have multiple clauses
    ancestor(X,Y) :-
        father(X,Y).
    ancestor(X,Y) :-
        father(X,Z),
        ancestor(Z,Y).
  #+end_src

  The =ancestor/2= rule here reads as follows:

        X is an ancestor of Y if
            either
                X is the father of Y
            or
                X is the father of Z and Z is the ancestor of Y

- Predicates can also be queried in reverse
- Recursive rules can sometimes cause stack overflow. When it does, try tail recursive optimization.

*Lists & Tuples*
- Lists and tuples are denoted [a,b,c] and (1,2,3) respectively
- Their strengths come out with unification operations within prolog


- Tuples unify element-wise strictly
- A tuple unification with variables on both sides is possible
  #+begin_src prolog
    ?- (A,2,C)=(1,B,3).

    A = 1,
    B = 2,
    C = 3.

  #+end_src


- List unification has one added feature, =|=
  #+begin_src prolog
    ?- [1,2,3]=[A|B].
    A = 1,
    B = [2,3].

    ?- [1]=[A|B].
    A = 1,
    B = [].

    ?- []=[A|B].
    false.

    ?- [a, b, c, d, e] = [_, _|[H|_]].
    H = c.
  #+end_src

- recursive math w/ lists can be done as follows:
  #+begin_src prolog :tangle math.pl
    count(0,[]). % the base case; an empty list has count 0
    count(Count,[_|T]) :- count(TCount, T), Count is TCount + 1. % note the "is" operator

    sum(0,[]).
    sum(Total,[H|T]) :- sum(Sum,T), Total is H + Sum.

    % I'm guessing prolog handles the type checking for average?
    average(Avg, List) :- sum(Sum,List), count(Count,List), Avg is Sum/Count.

  #+end_src

- =append\3= can be quite useful
  #+begin_src prolog
    ?- append([oil], [water], [oil, water]).
    true.


    ?- append([oil], [water], [oil, slick]).
    false.


    ?- append([tiny], [bubbles], What).
    What = [tiny,bubbles].


    ?- append([dessert_topping], Who, [dessert_topping, floor_wax]).
    Who = [floor_wax].


    ?- append(One, Two, [apples, oranges, bananas]).â€‹
    One = [],
    Two = [apples,oranges,bananas] ;
    One = [apples],
    Two = [oranges,bananas] ;
    One = [apples,oranges],
    Two = [bananas] ;
    One = [apples,oranges,bananas],
    Two = [] ;
    false.
  #+end_src

we can write our own version of =append/3= as follows:
#+begin_src prolog :tangle concatenate.pl
  % this is our base case; appending an empty list to anything returns itself.
  concatenate([],List,List).

  concatenate([H|[]], List, [H|List]) % concatenating a single-element list to another list.
  concatenate([H1|[H2|[]]],List, [H1,H2|List]).
  concatenate([H1|[H2|[H3|[]]]],List, [H1,H2,H3|List])

  % ... so on and so forth...


  % we can generalize the inductive rules as follows:
  concatenate([H|T1],List,[H|T2]) :- concatenate(T1,List,T2).
  % recall that Y :- X is read as: if X then Y (X implies Y)
  % the above statement then reads as
  %       if the concatenation of the first list's tail & the second list is the third lists tail,
  %           and the heads of the first and third lists are the same,
  %               then the concatenation of the first list and the second list is the third.
  %
  % concretely,
  %   this means that the tail of the first list is traversed until we reach an empty list,
  %       then the base case is proven true, after which the recursed implications are inductively true as well.

#+end_src

*** Self-study
*Find*
1) I didn't wanna find them, so I just tried writing them myself.
   #+begin_src prolog :tangle fibonacci.pl
     % base cases
     fibonacci(0,0).
     fibonacci(1,1).

     % general recursive case.
     fibonacci(N,X) :-
         N > 1,
         succ(N1,N),
         succ(N2,N1),
         fibonacci(N1,S1),
         fibonacci(N2,S2),
         X is S1+S2.
   #+end_src

Halfway through writing this I got stuck because I was using =fibonacci(N-1,S1)= and =fibonacci(N-2,S2)=. Prolog doesn't allow mathematical operations like =2-1= in general, so I had to consult http://cubbi.com/fibonacci/prolog.html

pretty cool stuff on the website.

2)

3)


*Do*
1) Reverse the elements of a list
   #+begin_src prolog :tangle listReverse.pl
     reverse([H|T],List) :-
         reverse(T,Hprime),
         append(Hprime,[H],List).
   #+end_src

2) Find the smallest element of a list
   #+begin_src prolog :tangle smallest.pl
     smallest([Min],Min).
     smallest([H1,H2|T],Min) :-
         H3 is min(H1,H2),
         smallest([H3|T],Min).
   #+end_src

3) Sort the elements of a list (I guess it's time to bubblesort?)
   #+begin_src prolog :tangle bubble.pl
     bubblesort([H|T],Sorted) :-
         bubblesort([H|T],[H], Sorted).

     bubblesort([],SL,SL).
     bubblesort([H|T],[H2|T2],SL) :-
         H =< H2,
         bubblesort(T,[H,H2|T2],SL).
     bubblesort([H|T],[H2|T2],SL) :-
         H > H2,
         bubblesort([H],T2,TN),
         bubblesort(T,[H2|TN],SL).
   #+end_src
